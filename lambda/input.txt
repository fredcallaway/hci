Lambda

#constants of type e : it
#constants of type <e,e> : C 
#constants of type <e,t> : S
variables of type e : a-o r-z
variables of type <e,t> : P-Q
variables of type t : p q
variables of type <e,et> : R
variables of type <et,t> : T
variables of type <<e,t>,e> : A

multiple letter identifiers

use rule function application
use rule non-branching nodes
use rule predicate modification
use rule lambda abstraction

#screen
define screen: Lx[screen(x)]

#shapes
define circle: Lx[circle(x)]
define square: Lx[square(x)]
define triangle: Lx[triangle(x)]

#colors
define red: Lx[red(x)]
define orange: Lx[orange(x)]
define yellow: Lx[yellow(x)]
define green: Lx[green(x)]
define blue: Lx[blue(x)]
define purple: Lx[purple(x)]
define white: Lx[white(x)]
define black: Lx[black(x)]

#actions
#replace 'draw' below with name of python command?
define draw: Lx[draw(x)]
#make1 = draw; it creates a new object and puts it on the screen
define make1: Lx[draw(x)]
#make2 modifies the parameters of an existing object on the screen
#define make2: LPLx[P(x)]

#function words
define a: LP.P
define the: LP[Iy(P(y))]
#it is the name of the python variable that contains the identity of
#the last updated element
#define it: it

# Dummy function that lets the Plop code find the result.
# define result : LP.result(P)
define result : Lp.result(p)

exercise tree
title TITLE
directions TITLE

[result [.VP [.V draw][.DP[.D the][.AP[.A red][.NP square]]]]]
